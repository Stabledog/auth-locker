<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="Content-Security-Policy" 
        content="default-src 'self'; script-src 'unsafe-inline' 'self'; style-src 'unsafe-inline' 'self';">
  <title>üîê Auth Locker - Secret Recovery</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 20px;
    }

    .container {
      background: white;
      border-radius: 12px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
      max-width: 600px;
      width: 100%;
      padding: 40px;
    }

    header {
      text-align: center;
      margin-bottom: 30px;
    }

    h1 {
      font-size: 28px;
      color: #333;
      margin-bottom: 8px;
    }

    .subtitle {
      color: #666;
      font-size: 14px;
    }

    .input-group {
      margin-bottom: 20px;
    }

    label {
      display: block;
      font-weight: 600;
      color: #333;
      margin-bottom: 8px;
      font-size: 14px;
    }

    .password-wrapper {
      position: relative;
    }

    input[type="password"],
    input[type="text"] {
      width: 100%;
      padding: 12px 40px 12px 12px;
      border: 2px solid #ddd;
      border-radius: 6px;
      font-size: 16px;
      transition: border-color 0.2s;
    }

    input:focus {
      outline: none;
      border-color: #667eea;
    }

    .toggle-password {
      position: absolute;
      right: 12px;
      top: 50%;
      transform: translateY(-50%);
      background: none;
      border: none;
      cursor: pointer;
      color: #666;
      font-size: 20px;
      padding: 4px;
    }

    .button-group {
      display: flex;
      gap: 12px;
      margin-bottom: 20px;
    }

    button {
      flex: 1;
      padding: 12px 24px;
      border: none;
      border-radius: 6px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
    }

    .btn-primary {
      background: #667eea;
      color: white;
    }

    .btn-primary:hover:not(:disabled) {
      background: #5568d3;
    }

    .btn-secondary {
      background: #e0e0e0;
      color: #333;
    }

    .btn-secondary:hover:not(:disabled) {
      background: #d0d0d0;
    }

    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .status {
      padding: 12px;
      border-radius: 6px;
      margin-bottom: 20px;
      display: none;
      font-size: 14px;
    }

    .status.show {
      display: block;
    }

    .status.loading {
      background: #e3f2fd;
      color: #1976d2;
    }

    .status.error {
      background: #ffebee;
      color: #c62828;
    }

    .status.success {
      background: #e8f5e9;
      color: #2e7d32;
    }

    .output-section {
      display: none;
    }

    .output-section.show {
      display: block;
    }

    .output-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
    }

    .output-header h3 {
      font-size: 14px;
      font-weight: 600;
      color: #333;
    }

    .btn-copy {
      background: #667eea;
      color: white;
      padding: 6px 12px;
      border: none;
      border-radius: 4px;
      font-size: 12px;
      cursor: pointer;
      transition: background 0.2s;
    }

    .btn-copy:hover {
      background: #5568d3;
    }

    .output-box {
      background: #f5f5f5;
      border: 1px solid #ddd;
      border-radius: 6px;
      padding: 16px;
      max-height: 300px;
      overflow-y: auto;
      font-family: 'Courier New', Courier, monospace;
      font-size: 14px;
      line-height: 1.6;
      white-space: pre-wrap;
      word-wrap: break-word;
      user-select: all;
    }

    .timer {
      text-align: center;
      color: #666;
      font-size: 12px;
      margin-top: 12px;
    }

    footer {
      margin-top: 30px;
      text-align: center;
      color: #999;
      font-size: 12px;
    }

    @media (max-width: 640px) {
      .container {
        padding: 24px;
      }

      h1 {
        font-size: 24px;
      }

      .button-group {
        flex-direction: column;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>üîê Auth Locker</h1>
      <p class="subtitle" id="subtitle">Secret Recovery Tool</p>
    </header>

    <div class="status" id="status"></div>

    <div class="input-group">
      <label for="passphrase">Recovery Passphrase</label>
      <div class="password-wrapper">
        <input 
          type="password" 
          id="passphrase" 
          placeholder="Enter your recovery passphrase"
          autocomplete="off"
          aria-label="Recovery passphrase">
        <button class="toggle-password" id="togglePassword" type="button" aria-label="Toggle password visibility">
          üëÅÔ∏è
        </button>
      </div>
    </div>

    <div class="button-group">
      <button class="btn-primary" id="decryptBtn">Decrypt</button>
      <button class="btn-secondary" id="clearBtn">Clear</button>
    </div>

    <div class="output-section" id="outputSection">
      <div class="output-header">
        <h3>Decrypted Content</h3>
        <button class="btn-copy" id="copyBtn">Copy</button>
      </div>
      <pre class="output-box" id="output"></pre>
      <div class="timer" id="timer"></div>
    </div>

    <footer>
      Client-side decryption only ‚Ä¢ No server communication after load
    </footer>
  </div>

  <script>
    // Crypto parameters (must match encryption script)
    const PBKDF2_ITERATIONS = 200000;
    const PBKDF2_KEYLEN = 256; // bits
    const PBKDF2_HASH = 'SHA-256';
    const GCM_TAG_LENGTH = 16; // bytes
    const AUTO_CLEAR_SECONDS = 60;

    // Detect locker name from URL path
    // Expected format: /auth-locker/lockername/ or /lockername/
    function getLockerName() {
      const path = window.location.pathname;
      // Remove trailing slash and split by /
      const parts = path.replace(/\/$/, '').split('/');
      // Get the last part of the path (locker name)
      const lockerName = parts[parts.length - 1];
      // If it's empty or looks like a project name, return null (use default)
      if (!lockerName || lockerName === 'auth-locker' || lockerName === 'locker.html') {
        return null;
      }
      return lockerName;
    }

    // Get content.txt path based on locker name
    function getContentPath() {
      const lockerName = getLockerName();
      if (lockerName) {
        return 'content.txt'; // Relative to the locker directory
      }
      return 'content.txt'; // Default location
    }

    // Update subtitle with locker name
    const lockerName = getLockerName();
    if (lockerName) {
      document.getElementById('subtitle').textContent = `Locker: ${lockerName}`;
    }

    // Global state
    let encryptedData = null;
    let clearTimer = null;

    // DOM elements
    const passphraseInput = document.getElementById('passphrase');
    const togglePasswordBtn = document.getElementById('togglePassword');
    const decryptBtn = document.getElementById('decryptBtn');
    const clearBtn = document.getElementById('clearBtn');
    const copyBtn = document.getElementById('copyBtn');
    const statusDiv = document.getElementById('status');
    const outputSection = document.getElementById('outputSection');
    const outputPre = document.getElementById('output');
    const timerDiv = document.getElementById('timer');

    // Status message helper
    function showStatus(message, type) {
      statusDiv.textContent = message;
      statusDiv.className = `status show ${type}`;
    }

    function hideStatus() {
      statusDiv.className = 'status';
    }

    // Base64 to ArrayBuffer conversion
    function base64ToArrayBuffer(base64) {
      const binaryString = atob(base64);
      const bytes = new Uint8Array(binaryString.length);
      for (let i = 0; i < binaryString.length; i++) {
        bytes[i] = binaryString.charCodeAt(i);
      }
      return bytes.buffer;
    }

    // Load and parse content.txt
    async function loadEncryptedContent() {
      try {
        showStatus('Loading encrypted content...', 'loading');
        
        const contentPath = getContentPath();
        const response = await fetch(contentPath);
        if (!response.ok) {
          throw new Error(`Failed to load ${contentPath}`);
        }
        
        const text = await response.text();
        const lines = text.trim().split('\n');
        
        if (lines.length !== 3) {
          throw new Error('Invalid content.txt format');
        }

        const data = {};
        for (const line of lines) {
          const [key, value] = line.split('=');
          if (!key || !value) {
            throw new Error('Malformed content.txt line');
          }
          data[key.trim()] = value.trim();
        }

        if (!data.SALT_B64 || !data.IV_B64 || !data.CT_B64) {
          throw new Error('Missing required fields in content.txt');
        }

        encryptedData = {
          salt: base64ToArrayBuffer(data.SALT_B64),
          iv: base64ToArrayBuffer(data.IV_B64),
          ciphertext: base64ToArrayBuffer(data.CT_B64)
        };

        hideStatus();
        decryptBtn.disabled = false;
        
      } catch (error) {
        showStatus(`Error: ${error.message}`, 'error');
        decryptBtn.disabled = true;
      }
    }

    // Decrypt function
    async function decrypt() {
      const passphrase = passphraseInput.value;
      
      if (!passphrase) {
        showStatus('Please enter your passphrase', 'error');
        return;
      }

      if (!encryptedData) {
        showStatus('Encrypted content not loaded', 'error');
        return;
      }

      try {
        showStatus('Deriving encryption key...', 'loading');
        decryptBtn.disabled = true;

        // Import passphrase as key material
        const enc = new TextEncoder();
        const keyMaterial = await crypto.subtle.importKey(
          'raw',
          enc.encode(passphrase),
          'PBKDF2',
          false,
          ['deriveKey']
        );

        // Derive AES-GCM key using PBKDF2
        const key = await crypto.subtle.deriveKey(
          {
            name: 'PBKDF2',
            salt: encryptedData.salt,
            iterations: PBKDF2_ITERATIONS,
            hash: PBKDF2_HASH
          },
          keyMaterial,
          {
            name: 'AES-GCM',
            length: PBKDF2_KEYLEN
          },
          false,
          ['decrypt']
        );

        showStatus('Decrypting...', 'loading');

        // Decrypt using AES-GCM
        const decrypted = await crypto.subtle.decrypt(
          {
            name: 'AES-GCM',
            iv: encryptedData.iv
          },
          key,
          encryptedData.ciphertext
        );

        // Convert to UTF-8 string
        const plaintext = new TextDecoder().decode(decrypted);
        
        // Display result
        outputPre.textContent = plaintext;
        outputSection.classList.add('show');
        showStatus('‚úì Decryption successful', 'success');
        
        // Start auto-clear timer
        startAutoClearTimer();
        
      } catch (error) {
        showStatus('Decryption failed. Wrong passphrase?', 'error');
        outputSection.classList.remove('show');
      } finally {
        decryptBtn.disabled = false;
      }
    }

    // Clear function
    function clear() {
      passphraseInput.value = '';
      outputPre.textContent = '';
      outputSection.classList.remove('show');
      hideStatus();
      stopAutoClearTimer();
    }

    // Copy to clipboard
    async function copyToClipboard() {
      try {
        await navigator.clipboard.writeText(outputPre.textContent);
        const originalText = copyBtn.textContent;
        copyBtn.textContent = 'Copied!';
        setTimeout(() => {
          copyBtn.textContent = originalText;
        }, 2000);
      } catch (error) {
        showStatus('Failed to copy to clipboard', 'error');
      }
    }

    // Auto-clear timer
    function startAutoClearTimer() {
      stopAutoClearTimer();
      let remaining = AUTO_CLEAR_SECONDS;
      
      const updateTimer = () => {
        if (remaining <= 0) {
          clear();
          showStatus('Content auto-cleared for security', 'success');
          setTimeout(hideStatus, 3000);
        } else {
          timerDiv.textContent = `Content will auto-clear in ${remaining}s`;
          remaining--;
          clearTimer = setTimeout(updateTimer, 1000);
        }
      };
      
      updateTimer();
    }

    function stopAutoClearTimer() {
      if (clearTimer) {
        clearTimeout(clearTimer);
        clearTimer = null;
      }
      timerDiv.textContent = '';
    }

    // Toggle password visibility
    togglePasswordBtn.addEventListener('click', () => {
      const type = passphraseInput.type === 'password' ? 'text' : 'password';
      passphraseInput.type = type;
      togglePasswordBtn.textContent = type === 'password' ? 'üëÅÔ∏è' : 'üôà';
    });

    // Event listeners
    decryptBtn.addEventListener('click', decrypt);
    clearBtn.addEventListener('click', clear);
    copyBtn.addEventListener('click', copyToClipboard);
    
    passphraseInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') {
        decrypt();
      }
    });

    // Load encrypted content on page load
    loadEncryptedContent();
  </script>
</body>
</html>
